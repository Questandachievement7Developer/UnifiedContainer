#!/bin/bash

# ------------------[Important NOTE!]-----------------------------
# ‚úÖ DONE : Tidying up required for the reboot of Unified Container
# ‚úÖ DONE : Convert UnifiedContainer from Arch Linux to Alpine for Maximum Compatibility with Android, Pure GNU/Linux, WSL, and iOS
# ‚úÖ DONE : Design UnifiedContainer To make sure it doesnt require Termux or any Repository for its first run for four architechture x86_64 x86 armv7l arm64
# ‚åõ TODO : Do a paper on this Project, because of this Tidying up the code and trimming the unecessary code is required!!
# ‚åõ TODO : Make pdf that have the guide on how to use this product : from the commands to the demo of the real screenshot
# ‚úÖ DONE : Divide the code section to groups
# ‚úÖ DONE : Change the license to GPL V2 for compatibility 
# ‚úÖ DONE : Implement portable Static Bash Binary Alert its MIT license Resolve : MIT compatible with GPL v2
# ‚úÖ DONE : Make a compiler from Raise The Empires to combine with the Tarball of the portable binary
# ‚åõ TODO : Make git container import be stub first but then for future port it become scp or ssh for universal imports
# ‚úÖ DONE : Fix the reset routines of the unifyServer into "rm -rf managerbackup recovery containersys"
# ‚úÖ DONE : Optimize the package download speed ( right now its only feels like 5 KB/s )
# ‚úÖ DONE : WSL Known has a disk speed issues using 9pfs, Is there any optimization option?
# ‚úÖ DONE : Implement Seccomp Acceleration if the flag exist and user defined it to
# ‚åõ TODO [CRITICAL] : Solve the iSH Self-destruct unknown exec on Extracting rootfs stage 
# ‚åõ TODO [CRITICAL] : Solve the Termux missing library
# Progress State : Testing
# ----------------------------------------------------------------


# Initialization Base Program -------------------------------------------------------------------


#----- Colouring and Text Section
export initDir="$(pwd)"
red(){
printf '\e[38;5;210m' > /dev/tty
}
yellow(){
printf '\e[38;5;221m' > /dev/tty
}
green(){
printf '\e[38;5;042m' > /dev/tty
}
blue(){
printf '\e[38;5;039m' > /dev/tty
}
gray(){
printf '\e[38;5;037m' > /dev/tty
}
export red='\e[38;5;210m'
export yellow='\e[38;5;221m'
export green='\e[38;5;042m'
export blue='\e[38;5;039m'
export gray='\e[38;5;037m'
export pbadge="[Unified Container Manager]:"

intro(){
if [ ${newInstall} == '1' ] && [ ! -z ${newInstall} ]; then
  clear
blue
echo "==================================================================="
green
echo "üòä Warm welcome from QuestandachievementStudio Members üòä"
echo "üéÜ‚ú® Welcome to unifiedContainer Project‚ú®üéÜ"
echo "üëâ Heavily Inspired by docker, multipass, termuxarch sdrausty, and neoOli bootstrap üëç"
echo "üëâ Code sourced from MFDGaming NeoOli and Stackoverflow üëç"
blue
echo "==================================================================="
sleep 4
fi
}
#-----

#ROM Detection Section----
#if some assholes decided to not include which in the rootfs
if [ ! -f /bin/which ]; then
if [ -f /bin/busybox ]; then
which(){
busybox which
}
fi
#but what if another asshole doesnt want to include busybox due to business reason?
if [ -f /bin/toybox ]; then
which(){
toybox which
}
fi
fi
#--------


#-------Program Parameter Check
if [ ${diagnosticTrigger} == "1" ] && [ ! -z ${diagnosticTrigger} ]; then
export PrimaryParam=""
export SecondaryParam=""
export TertiaryParam=""
export quadtiaryParam=""
# a bug has been known tha
fi


if [ -z ${foreignenvironment} ] || [ ${foreignenvironment} == "0" ]; then # this if are for the Mitigation if it used in a AlternateEnvironment
export PrimaryParam=${1}
export SecondaryParam=${2}
export TertiaryParam=${3}
export quadtiaryParam=${4}
fi
#set -x
if [ ${DEVELENV} == "1" ] && [ ! -z ${DEVELENV} ]; then
echo DEBUG PARAM CHECK ${PrimaryParam} ${SecondaryParam}
fi
export managerGitlink="https://github.com/Questandachievement7Developer/UnifiedContainer"
export PATH="$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/mnt/c/Windows/system32:/mnt/c/Windows:/mnt/c/Windows/System32/Wbem:/mnt/c/Windows/System32/WindowsPowerShell/v1.0/:/mnt/c/Windows/System32/OpenSSH/:/mnt/c/ProgramData/chocolatey/bin"

export newInstall=0

paramCheck(){
#echo DEBUG PARAM CHECK ${PrimaryParam} ${SecondaryParam}
if [ -z ${PrimaryParam} ]; then
  red
  echo "${pbadge} ü§î No command detected Redirecting to help page for basic functions ü§∑"
  help_unifyServer
  exit
fi

if [ -z ${SecondaryParam} ]; then
  red
  echo "${pbadge} ü§î no parameter detected please refer help for manual ü§∑"
  help_unifyServer
  exit
fi

if [ ${SecondaryParam} == "default" ]; then
  clear
  red
  echo "${pbadge} Welco.. wait thats illegal! "
  exit
fi
}

#Detect current Distro that is likely to be present
distroDetection(){
# DISTRO MANAGER DETECTION IS ALSO USED TO DETERMINE WHERE DOES THE SCRIPT RUN and Directory Builder
export ptracecompat='1' #flag ptrace compatibility based on the distro or kernel that its running
export iSHenv="0"
export termuxenv="0"
export BLINDBOOT="0"
export linktosymlinkActivated=0
export arch=$(uname -m)
if [ ! -z $(which apk) ]; then
  echo "Alpine Distro"
  export packmanager=apk
  export installParameter="add"
  export distro="alpine"
fi

if [ ! -z $(which apt) ]; then
export packmanager="apt"
export installParameter="install -y"
export distro="debianGNU"
fi
    if [ ! -z $(which pkg) ]; then
    export packmanager="pkg"
    export installParameter="install -y"
    export linktosymlinkActivated=1
    echo Termux Detected
    export distro="termux"
    export termuxenv="1"
    unset LD_PRELOAD #to preload dependencies issues as describe when you have LD_PRELOAD set in the proot (termux) program

    fi


    if [ ! -z $(which yum) ]; then
    export packmanager="yum"
    export installParameter="install -y"
    export distro="centOSGNU"
    fi

    if [[ $( uname -a | grep Microsoft ) ]]; then
      echo "Bash is running on WSL"
      echo "PTRACE ON WSL 1 IS NOT SUPPORTED"
      export ptracecompat='0'
      export WSLenv="1"
    fi

    if [[ $( uname -a | grep iSH ) ]]; then
      echo "Bash is running on iSH"
      echo "PTRACE ON iSH IS NOT SUPPORTED"
      export iSHenv="1"
      export BLINDBOOT="1"
      export ptracecompat='0'
      export WSLenv="0"
    fi

    if [ ! -z $(which pacman) ]; then
    export packmanager="pacman"
    export installParameter="-Sy --noconfirm"
    export distro="archlinux"
    echo Redownloading Databases
    pacman -Syy
    fi

    if [ ! -z $(which easy_install) ]; then
    export pyPacman="easy_install"
    export pyInstallParam=""
    fi

    if [ ! -z $(which add-apt-repository) ]; then
    export packmanager="apt-get"
    export installParameter="install -y"
    fi

    if [ ! -z $(which pip) ]; then
    export pyPacman="pip"
    export pyInstallParam="install"
    fi


}

# Building Directory for the UnifiedContainer
folderInit(){
export origindir=$(pwd)
export maindir="${initDir}/containersys"
export rootfsprootRepoCache="${maindir}/rootfsprootRepoCache"
export recoveryEnvironmentDir="${origindir}/managerbackup"
export presistentStorage="${maindir}/presistent_storage"
export containersLair="${maindir}/containers"
export defaultContainer="${containersLair}/default"
export unasignedContainer="${containersLair}/unasigned"
export loader="${maindir}/portabletoolbox" #loader moved into rootfsprootRepoCache # Loader is basically busybox
export TMPFolder="${maindir}/tmp"
export apkTMPFolder="${TMPFolder}/pacmanCache" #basically will accelerate pacman Caches
export unasignedContainerTMP="${TMPFolder}/unasigned"
export logs="${maindir}/logs"
export containerExport=${maindir}/containerExport
export APIHAL=${maindir}/sysIO
export APIHAL_INPUT=${APIHAL}/input
export APIHAL_OUTPUT=${APIHAL}/output
export containerFilesList="${maindir}/containers.txt"
if [ ! -d ${recoveryEnvironmentDir} ]; then
mkdir ${recoveryEnvironmentDir}
fi

if [ ! -d ${maindir} ]; then
  mkdir ${maindir}
fi

if [ ! -d ${APIHAL} ]; then
  mkdir ${APIHAL}
fi

if [ ! -d ${APIHAL_INPUT} ]; then
  mkdir ${APIHAL_INPUT}
fi

if [ ! -d ${APIHAL_OUTPUT} ]; then
  mkdir ${APIHAL_OUTPUT}
fi

if [ ! -d ${presistentStorage} ]; then
  mkdir ${presistentStorage}
fi

if [ ! -d ${containerExport} ]; then
  mkdir ${containerExport}
fi

if [ ! -d ${TMPFolder} ]; then
  mkdir ${TMPFolder}
fi

if [ ! -d ${apkTMPFolder} ]; then
  mkdir ${apkTMPFolder}
fi

if [ ! -d ${logs} ]; then
  mkdir ${logs}
fi

if [ ! -d ${containersLair} ]; then
  mkdir ${containersLair}
fi

if [ ! -d ${defaultContainer} ]; then
  mkdir ${defaultContainer}
  export newInstall=1
else
  export newInstall=0
fi

if [ ! -d ${rootfsprootRepoCache} ]; then
  mkdir ${rootfsprootRepoCache}
  cp rootfsprootRepoCache ${rootfsprootRepoCache}
  backdir=$(pwd)
  cd ${rootfsprootRepoCache}
  tar -xvf rootfsprootRepoCache
  cd ${backdir}
fi

if [ ! -d ${loader} ]; then
  mkdir ${loader}
  export PATH=${loader}:${PATH}
fi

}
#------


#Environment Compatible API Calls detection

APIcall(){
  dummyResponse(){
  echo "${pbadge} Current version of API Abstraction Layer is unsupported for your current environment"
  }
  #This function is basically like a API abstraction layer
  #red
  #echo "${pbadge} Function is not implemented"
  #echo '[DEBUG] APIcall() function only supported for termux '
  #yellow
  #echo "${pbadge} Detecting available API"
  #echo '[WARN] Wakelock, Notification, Humain interface input, Sensors may not work on current version'#

  #____________________________
  #Hardware Acceleration Setup
  #OpenCL
  opencl_forward(){
    echo "${pbadge} Function is not yet implemented"
  }
  #__________________________
  if [ ${distro} == "termux" ]; then
    #systemUI calls
    #echo "Using Termux API"
    systemUI_notifysend(){ termux-notification "${1}" "${2}" "${3}" "${4}" ;}
    systemUI_directNotification(){ termux-toast "${1}" "${2}" "${3}" "${4}" ;}
    systemUI_nativeDownload(){ termux-download "${1}" "${2}" "${3}" "${4}" ;}
    systemUI_clipboard_get(){ termux-clipboard-get; }
    systemUI_clipboard_set(){ termux-clipboard-set; }
    systemUI_authFingerprint(){ termux-fingerprint; }
    #Power management calls
    pwmCall_batterystat(){ termux-battery-status; }
    pwmCall_enable_wakelockcall(){ termux-wake-lock; }
    pwmCall_disable_wakelockcall(){ termux-wake-unlock; }
    pwmCall_brightnessAdjust(){ termux-brightness; }
    #Sensors call
    sense_Retrievesensor(){ termux-sensor; }
    #radiocall
    tele_sms_read(){ termux-sms-list; }
    tele_sms_send(){ termux-sms-send; }
    tele_voice_call(){ termux-telephony-call ${1} ${2} ${3} ;}
    #hardware access
    hw_usb(){ termux-usb ${1} ${2} ${3} ;}
  fi
  if [ ${distro} == "debianGNU" ] || [ ${distro} == "iSH" ] || [ ${distro} == "debian" ] || [ ${distro} == "archlinux" ]; then
    #systemUI calls
    #echo "Using Generic GNU/Linux calls"
    systemUI_notifysend(){ echo [INFO] ${pbadge}; }
    if [ ! -z $(which xmessage) ]; then
    systemUI_directNotification(){ xmessage; }
  else
    systemUI_directNotification(){ echo [INFO] ${pbadge}; }
  fi
  if [ ${WSLenv} == "1" ] && [ ! -z ${WSLenv} ]; then
    #echo "Using WSL specific calls"
  systemUI_directNotification(){ powershell.exe New-BurntToastNotification -Text "${1}" "${2}" "${3}" "${4}" ; }
  systemUI_notifysend(){ powershell.exe New-BurntToastNotification -Text "${1}" "${2}" "${3}" "${4}"; }
fi
    alias systemUI_sensorpoll="dummyResponse"
    if [ ! -z $(which aria2c) ]; then
    systemUI_nativeDownload(){ aria2c; }
  else
    systemUI_nativeDownload(){ wget; }
  fi
    if [ ! -z $(which xclip) ]; then
    systemUI_clipboard_get(){ xclip; }
    systemUI_clipboard_set(){ xclip -selection c; }
  else
    alias systemUI_clipboard_get="dummyResponse"
    alias systemUI_clipboard_set="dummyResponse"
  fi
    alias systemUI_authFingerprint="dummyResponse"
    #Power management calls
    if [ ! -d /proc/acpi ]; then
    alias pwmCall_batterystat="termux-battery-status"
    alias pwmCall_enable_wakelockcall="termux-wake-lock"
    alias pwmCall_disable_wakelockcall="termux-wake-unlock"
    alias pwmCall_brightnessAdjust="termux-brightness"
  else
    alias pwmCall_batterystat="dummyResponse"
    alias pwmCall_enable_wakelockcall="dummyResponse"
    alias pwmCall_disable_wakelockcall="dummyResponse"
    alias pwmCall_brightnessAdjust="dummyResponse"
  fi
    #Sensors call
    export sense_Retrievesensor="dummyResponse"
    #radiocall
    alias tele_sms_read="dummyResponse"
    alias tele_sms_send="dummyResponse"
    alias tele_voice_call="dummyResponse"
    #hardware access
    hw_usb(){ lsusb ; }
  fi
  # use distroDetection to determine its API usage
  # API that is need to be implemented are but not limited
  # Wakelock, Notification, Human interface input, Sensors

#125
#https://unix.stackexchange.com/questions/1496/why-doesnt-my-bash-script-recognize-aliases
#First of all, as ddeimeke said, aliases by default are not expanded in non-interactive shells.
#Second, .bashrc is not read by non-interactive shells unless you set the BASH_ENV environment variable.
#But most importantly: don't do that! Please? One day you will move that script somewhere where the necessary aliases are not set and it will break again.
#Instead set and use environment variables as shortcuts in your script:
  "${1}" "${2}" "${3}" "${4}" &
}

#----A routine where it checks whether SECCOMP acceleration is available or not
SECCOMP_Acceleration_Availability_detection(){
#proot Seccomp Acceleration SEGFAULT CRASHES FIX SIGNAL 11 TERMINATION
#On new UnifiedContainer the program have to detects whether it is supports SECCOMP or not
unset PROOT_NO_SECCOMP
echo "ALERT : Setting PROOT_NO_SECCOMP variable will cause havoc on the proot system for Unified Container, its best to permanently unset it and deprecate on later version"
functiondisable(){
export PROOT_NO_SECCOMP=0 #Enforce by default that it uses seccomp acceleration
echo "Checking Acceleration!"
${userspacebackend} ${symlinkfix} touch ${maindir}/acceleration_available # if its segfault then no acceleration and the file wont be created
if [ ! -f ${maindir}/acceleration_available ]; then
echo "Kernel or Environment is not stable to do acceleration, Disabling!"
uname -a
export PROOT_NO_SECCOMP=1
else
echo "Acceleration is Available!"
fi
}
}

#----Auto Debugging Functions
#https://stackoverflow.com/questions/4013947/how-to-use-pastebin-from-shell-script
sendLog() {
  if [[ $1 ]]; then
    curl -F 'sprunge=<-' "http://sprunge.us" <"$1"
  else
    curl -F 'sprunge=<-' "http://sprunge.us"
  fi
}

clearlog(){
rm -rf ${logs}/*.log
}

diagnosticsRun(){
clear
confirmation
folderInit # we need to do folderInit due to the fact that we skipped the boot sequence so the folder and other variable does not initialize unless we do folderInit
dependencies
#clearlog
#How about we send the full diagnostics? so we see what does the person did wrong?
clear
yellow
echo "================================================="
green
echo "UnifyServer Rapid Analysis and Compatibility test"
yellow
echo "================================================="
red
echo "Recording UnifyServer Behaviour for 10 minutes"
green
echo "While waiting for next instructions you can leave this program in the background"
echo "and get cup of green tea while murmuring about the rain"
yellow
echo "================================================="

functionTests(){
yellow
echo "=================="
export NOBOOT="" # we neeed to unset NOBOOT due to the fact NOBOOT parameter was exported globally caused a chaos while testing
green
export diagnosticTrigger=1
echo "Triggering Install"  >> ${logs}/diagnostics.log 2>&1
date >> ${logs}/diagnostics.log 2>&1
ash ${0} help all >> ${logs}/diagnostics.log  2>&1
yellow
echo "refresh"  >> ${logs}/diagnostics.log 2>&1
date >> ${logs}/diagnostics.log 2>&1
ash ${0} refresh yes >> ${logs}/diagnostics.log  2>&1
yellow
echo "import" >> ${logs}/diagnostics.log 2>&1
green
ash ${0} import 'https://github.com/Questandachievement7Developer/container_importExample' >> ${logs}/diagnostics.log  2>&1
yellow
echo "list" >> ${logs}/diagnostics.log 2>&1
green
ash ${0} list all >> ${logs}/diagnostics.log  2>&1
yellow
echo "refresh" >> ${logs}/diagnostics.log 2>&1
green
env SCRIPTCALL=1 ash ${0} reset ContainerImportTestfromGithub  >> ${logs}/diagnostics.log  2>&1
yellow
echo "Setup" >> ${logs}/diagnostics.log 2>&1
green
recoveryEnvironment >> ${logs}/diagnostics.log  2>&1
yellow
echo "remove"
green
env SCRIPTCALL=1 ash ${0} remove ContainerImportTestfromGithub  >> ${logs}/diagnostics.log  2>&1
yellow
echo "=================="
}
sendDiagnostics(){
    # Send diagnostics timeout is when the diagnostic are taking too long so it will interrupt and send the logs or diagnostic data without waiting for the diagnostic to finish
if [ $TIMEOUTWAIT == 1 ]; then
yellow
echo "${pbadge} [sendDiagnostics()] I have been launched! "
echo "${pbadge} [sendDiagnostics()] Dont worry we will be done in the next 10 Minutes "
sleep 100
echo "${pbadge} [sendDiagnostics()] journalizing it "
sleep 100
echo "${pbadge} [sendDiagnostics()] Intresting "
sleep 100
echo "${pbadge} [sendDiagnostics()] GNU/Linux are great "
sleep 100
echo "${pbadge} [sendDiagnostics()] I see the finish line "
sleep 100
echo "${pbadge} [sendDiagnostics()] We are almost done ! "
sleep 100

#http://morningcoffee.io/killing-a-process-and-all-of-its-descendants.html
echo "${pbadge} [sendDiagnostics()] 10 Minutes Tracing Done!"
kill -9 -- -${diagnosticThreadPID}
kill $(ps -s $diagnosticThreadPID -o pid=)
else
echo "Finished!"
kill -9 -- -${sendDiagnosticsTimeoutThreadPID}
fi
echo Compiling Logs and adding headers
echo "++++++unifySERVER DIAGNOSTIC LOG++++++" > ${origindir}/diagnostic_result.txt
echo "++++++DO NOT SHARE TO ANYONE IN ORDER TO PRESERVE YOUR PRIVACY TO THE FULLEST++++++" >> ${origindir}/diagnostic_result.txt
date >> ${origindir}/diagnostic_result.txt
uname -a >> ${origindir}/diagnostic_result.txt
echo "++++++++++MountPoint+++++++++++" >> ${origindir}/diagnostic_result.txt
mount >> ${origindir}/diagnostic_result.txt
echo "MOUNTPOINTEND+++++++++++++-----------" >> ${origindir}/diagnostic_result.txt

echo "Commmit Version $(git log -1 --format=%cd)" >> ${origindir}/diagnostic_result.txt
for a in $(ls ${logs}) ; do
echo "++++++++FILE_${a}++++++++" >> ${origindir}/diagnostic_result.txt
cat ${a} >> ${origindir}/diagnostic_result.txt
echo "=======END FILE_${a}=======" >> ${origindir}/diagnostic_result.txt
done
cat ${logs}/*.log >> ${origindir}/diagnostic_result.txt
clear
green
echo "Thank you for joining the survey Your contribution will help unifyServer!"
yellow
echo "========[Send this link to the developer]========="
green
sendLog "${origindir}/diagnostic_result.txt"
yellow
echo "=================================================="

}
#testing through debug mode
if [ ! -z $@ ]; then
${1} ${2} ${3} ${4}
else

sleep 1
green
echo "${pbadge} [THREAD] Experiment Started!"
functionTests >> ${logs}/diagnostics.log 2>&1 & #mutes any error that occours and save for later
export diagnosticThreadPID=$!
# Launch sendDiagnostics with TIMEOUTWAIT TO wait functiontests to finish
export TIMEOUTWAIT=1
yellow
echo "${pbadge} handing over to diagnostic timeout timer sendDiagnostics() ..."
yellow
sendDiagnostics
exit

fi


}
#---------------------



#TUI USER DISPLAY Section
debugFunct(){
sleep 4
clear
echo "================================================================="
red
echo " Do it at your own risk! You are on your own"
echo " Please refer to the code when calling a function "
echo "${pbadge} DEBUG MODE !"
echo
green
console(){
printf "\n unifyManager dbg console > "
read a
${a}
console
}
console
}


confirmation(){
  randcode=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)
  randcode="iwilltaketheresponsibilityofmyaction"
  yellow
  if [ -z ${SCRIPTCALL} ]; then
  echo "${pbadge} ‚ö†Ô∏è Are you sure that you want to do this ?‚ö†Ô∏è"
  echo "${pbadge} if you do please type this token"
  echo "${randcode}"
  echo "Your input: "
  read input
  echo "debug ${input}"
  fi
  if [ $input == $randcode ] || [ ! -z ${SCRIPTCALL} ] ; then #SCRIPTCALL VARIABLE IS FOR WHEN YOU CALL THIS SCRIPT THRROUGH A SCRIPT AND YOU WANTED TO HAVE no CONFIRMATION
    yellow
    echo "${pbadge} üöÄ Initiating dangerous code"
  else
    red
    echo "${pbadge} ‚ùå WRONG CODE CANCELLING ‚ùå"
  exit
fi
}

help_unifyServer(){
reset
echo "======="
echo "Unknown Parameter ${@}"
yellow
echo "${pbadge} Here are the commands"
echo "To launch container"
echo "${0} launch <containerName>"
echo "To Launch container in foreground"
echo "${0} launchfg <containerName>"
echo .
echo "To Stop container"
echo "${0} stop <containerName>"
echo .
echo "To Read Container Log"
echo "${0} logs <containerName>"
echo .
echo "To Grant local storage for the container"
echo "${0} exposeStorage <containerName>"
echo .
echo "To isolate local storage from the container"
echo "${0} deexposeStorage <containerName>"
echo .
echo "To Grant system Library for the container"
echo "${0} exposeSystemLibs <containerName>"
echo .
echo "To isolate system Library from the container"
echo "${0} deexposeSystemLibs <containerName>"
echo .
echo "Export Container Configuration "
echo "${0} exportCont <containerName>"
echo .
echo "reset container to default configuration"
echo "${0} reset <containerName>"
echo .
echo "List all the container and its status"
echo "${0} list All"
echo .
echo "reset Everything"
echo "DO THIS ONLY WHEN YOU HAVE A PROBLEM LIKE CORRUPTED INSTALLATION"
echo "${0} nuke yes"
echo .
echo "refresh main container"
echo "refresh main container to upgrade new bootloader version or fix unpredicter errors"
echo "${0} refresh yes"
echo .
echo "install program"
echo "This allows the unifiedContainer Technology to be installed and called easily "
echo "When program is installed it can be called \$bay param param"
echo "${0} install yes"
echo .
echo "to enter the container Shell"
echo "${0} shell <containerName>"
echo .
echo "to import container from the git server "
echo "${0} import <git repo link>"
echo .
echo "Fix container installation failures "
echo "${0} fix <containerName>"
echo .
echo "to update the container that imported from the git server"
echo "${0} update <containerName>"
echo .
echo "to export File or directory from host "
echo "${0} exportFile <containerName> <Source dir or File container> <Target dir on Host>"
echo .
echo "upgrade Container to newer version"
echo "${0} upgrade <containerName>"
echo .
echo "To execute a command on a container"
echo "${0} exec <containerName> <command>"
echo .
echo "To add container"
echo "${0} add <containerName>"
echo .
echo "To remove Container"
echo "${0} remove <containerName>"
echo .
echo "To edit exec Routines container"
echo "${0} edit_routines <containerName>"
echo "======="
exit
}

paramintrepreter(){
case ${PrimaryParam} in
  debug)
    debugFunct ;;
  importFile)
    sysFileExchangeImport ;;
  exportFile)
    sysFileExchangeExport ;;
  launch)
    launchcontainerSvc ;;
  install)
    linkManagerPath ;;
  refresh)
    upgradeMainContainer ;;
  logs)
    containerManagerLogs ;;
  launchfg)
    launchcontainerSvcFG ;;
  import)
    containerManagerImport ;;
  exportCont)
    containerManagerExport ;;
  exposeStorage)
    containerManagerExposeStorage ;;
  deexposeStorage)
    containerManagerDeExposeStorage ;;
  exposeSystemLibs)
    containerManagerExposeSystemLibrary ;;
  deexposeSystemLibs)
    containerManagerDeExposeSystemLibrary ;;
  reset)
    containerManagerReset ;;
  list)
    containerManagerList ;;
  stop)
      launchcontainerKill ;;
  nuke)
    nuke ;;
  shell)
    launchcontainerSHELL ;;
  exec)
    executeContainerCMD ;;
  add)
    containerManagerAdd ;;
  upgrade)
    containerManagerUpgrade ;;
  update)
    containerManagerUpdate ;;
  fix)
    containerManagerUpdate ;;
  remove)
    containerManagerrm ;;
  edit_routines)
    editroutinesContainer ;;
  *)
    menuUI ;;
esac
}
# if the bash is recognized this one rather the real one
# then it have a big problem

# bash does not recognize this function

#-------------------------



#----------------------------------------------------------------- Program Initialization END

#----------- Container Management
# for Adding Container, Exporting, Deleting, or Full RESET of the Unified Container
#Import Container from git server
containerManagerImport(){
  if [ ! -z $@ ] ; then
    SecondaryParam=${1}
    TertiaryParam=${2}
  fi
APIcall systemUI_notifysend "‚åõImporting_container‚åõ"
echo "${pbadge} ‚åõImporting container configuration ‚åõ"
containerID=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)
export importedcontainer="${TMPFolder}/${containerID}"
git clone ${SecondaryParam} ${TMPFolder}/${containerID} > ${logs}/${containerID}_gitcloneLog.log 2>&1
if [ ! -d "${TMPFolder}/${containerID}" ]; then
  red
  echo "${pbadge} ‚ùå Imported Container does not exists ‚ùå"
  exit
fi
export GITSOURCE="${SecondaryParam}"
name=$(cat ${importedcontainer}/name)
packages=$(cat ${importedcontainer}/packages)
init=$(cat ${importedcontainer}/init)
setuproutines=$(cat ${importedcontainer}/setup)
rootfsConfig=${importedcontainer}/additional_container_configuration
cd ${origindir}
if [ -z ${updateContainer} ]; then
containerManagerAdd ${name}
fi

ImportedContainerPackageManager(){
APIcall pwmCall_enable_wakelockcall
echo "${GITSOURCE}" > ${containersLair}/${name}/origin #add the source link first so if the installs fails user can easily reset the container
echo "${packages}" > ${containersLair}/${name}/rootfs/packages
export totalpackage=0
for b in ${packages}; do
totalpackage=$((totalpackage + 1))
done
currentpackage=0
for a in ${packages}; do
currentpackage=$((currentpackage + 1))
percentage=$((currentpackage * 100 / totalpackage))
#ash ${0} exec ${name} "apt install -y < /packages"
yellow
export SecondaryParamOld="${SecondaryParam}"
echo "${pbadge} ‚åõ Installing Dependencies ${percentage} %"
export NOBOOT=1 # to prevent any Uncessary checks when reexecuting
ash ${0} exec ${name} "apk update" >> ${logs}/unifyServerPackageInstaller.log 2>&1
ash ${0} exec ${name} "apk add ${a}" >> ${logs}/unifyServerPackageInstaller.log 2>&1
#Efficient code seems to not working? I dont know why?
#executeContainerCMD ${name} "pacman -Syy" >> ${logs}/unifyServerPackageInstaller.log 2>&1
#executeContainerCMD ${name} "pacman -S --needed --noconfirm ${a}" >> ${logs}/unifyServerPackageInstaller.log 2>&1
#executeContainerCMD ${name} "pacman -S --needed --noconfirm ${a}"
green
echo "${pbadge} ‚úîÔ∏è Done Installing ${a} "
done


}

ImportedContainerPackageManager

echo "${GITSOURCE}" > ${containersLair}/${name}/origin
echo "${init}" > ${containersLair}/${name}/rootfs/init
echo "${setuproutines}" > ${containersLair}/${name}/rootfs/setup
echo "${pbadge} ‚ú®Container Finishing touch‚ú®"
echo "${pbadge} Checking rootfs cache"
if [ -d ${rootfsConfig} ]; then
  ${userspacebackend} ${symlinkfix} cp -raH ${rootfsConfig}/* ${containersLair}/${name}/rootfs
fi
#executeContainerCMD ${name} "bash /setup"
echo "${GITSOURCE}" > ${containersLair}/${name}/origin
ash ${0} exec ${name} "bash /setup"
green
APIcall systemUI_notifysend "‚ú®Container_${SecondaryParam}_Successfully_Installed‚ú®"
echo "${GITSOURCE}" > ${containersLair}/${name}/origin
echo "${pbadge} ‚ú®import done‚ú®"
APIcall pwmCall_disable_wakelockcall
exit
}

#Export Container
containerManagerExport(){
APIcall pwmCall_enable_wakelockcall
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  fi
name=${SecondaryParam}
#ash ${0} exec ${SecondaryParam} "apt list --installed > /packages" #https://askubuntu.com/questions/9135/how-to-backup-settings-and-list-of-installed-packages
#ash ${0} exec ${SecondaryParam} "pacman -Qqe > /packages"
executeContainerCMD ${name} "pacman -Qqe > /packages"
packages=$(cat ${containersLair}/${SecondaryParam}/rootfs/packages)
init=$(cat ${containersLair}/${SecondaryParam}/rootfs/init)
echo '# You can edit the setup runtime in here (This installation happens post package installation)' > ${containerExport}/${name}/setup
executeContainerCMD ${name} "history" >> ${containerExport}/${name}/setup
nano ${containerExport}/${name}/setup
mkdir ${containerExport}/${name}
echo "${name}" > ${containerExport}/${name}/name
echo "${packages}" > ${containerExport}/${name}/packages
echo '# You can edit the init file anything you want (Executed everytime launched the container)' > ${containerExport}/${name}/init
echo "${init}" >> ${containerExport}/${name}/init
nano ${containerExport}/${name}/init
#echo "apt-get update; apt-get upgrade; echo Default setup done" > ${containerExport}/${name}/setup
#echo "pacman -Syu --noconfirm ; echo Default setup done" > ${containerExport}/${name}/setup
green
echo "${pbadge} ‚ú®export done‚ú®"
APIcall pwmCall_disable_wakelockcall
exit
}

#Add a blank container
containerManagerAdd(){
  if [ ! -z $@ ] ; then
    SecondaryParam=${1}
    TertiaryParam=${2}
  fi
  if [ -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} Container Exists"
    exit
  else
    yellow
    echo "${pbadge} üì¶ Creating Container"
  if [ ! -d ${unasignedContainer} ] || [ ! -f ${unasignedContainer}/cacheSuccess ]; then
    if [ -f ${containersLair}/defaultSeq ] && [ -f ${containersLair}/guranteedSeqIntegrity ]; then
    echo "Optimization Enabled"
      mkdir ${containersLair}/${SecondaryParam}
      ${userspacebackend} ${symlinkfix} tar -C "${containersLair}/${SecondaryParam}" -xf "${containersLair}/defaultSeq" >> ${logs}/rootfsOptimizedCopyOperation.log 2>&1
      #mv ${containersLair}/${SecondaryParam}/default/* ${containersLair}/${SecondaryParam} #this is unused since the tar compressed directly from the directory
      #rm -rf ${containersLair}/${SecondaryParam}/default
  else
    echo "Optimization Disabled"
      ${userspacebackend} ${symlinkfix} cp -raH "${defaultContainer}" "${containersLair}/${SecondaryParam}" >> ${logs}/rootfsCopyOperation.log 2>&1
  fi
else
echo "${pbadge} Super Optimization Available"
mv -v ${unasignedContainer} ${containersLair}/${SecondaryParam} >> ${logs}/containerAheadOptimizationCacheMove.log 2>&1
containerAheadOptimizationCache > ${logs}/containerAheadOptimizationCache.log 2>&1 & #This will trigger the creation of additional unasigned container
#echo $! > ${maindir}/containerOptimizationPID
fi
    echo "$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)" > ${containersLair}/${SecondaryParam}/containerID
    echo "${pbadge} üì¶ Creating Presistent data"
    mkdir "${presistentStorage}/$(cat ${containersLair}/${SecondaryParam}/containerID)"
    green
    APIcall systemUI_notifysend "‚úîÔ∏è_Container_${SecondaryParam}_Successfully_Created"
    echo "${pbadge} ${SecondaryParam} ‚úîÔ∏è Container done"
    echo "${SecondaryParam}" >> ${containerFilesList}
    if [ -z $@ ] ; then
      exit
    fi
  fi

}

#Reset Container
containerManagerReset(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
    confirmation
    yellow
    echo "${pbadge} üì¶ Resetting Container"
    if [ -f "${containersLair}/${SecondaryParam}/origin" ]; then
      echo "${pbadge} üì¶ Resetting Remote Container"
      originLink="$(cat ${containersLair}/${SecondaryParam}/origin)"
      echo "${originLink}"
      cd ${origindir}
      ${userspacebackend} ${symlinkfix} rm -rf "${containersLair}/${SecondaryParam}"
      ash ${0} import "${originLink}"
    else
      echo "${pbadge} üì¶ Resetting Local Container"
    ${userspacebackend} ${symlinkfix} rm -rf "${containersLair}/${SecondaryParam}"
    ${userspacebackend} ${symlinkfix} cp -raH "${defaultContainer}" "${containersLair}/${SecondaryParam}" >> ${logs}/rootfsCopyOperation.log  2>&1
  fi
    green
    echo "${pbadge} ${SecondaryParam} ‚úîÔ∏è Container done"
    exit
  fi

}

#Delete Container
containerManagerrm(){
  if [ -z ${removalretry} ]; then
  confirmation
fi
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
    yellow
    echo "${pbadge} üóëÔ∏è Removing Container ${SecondaryParam}"
    if [ -f ${maindir}/NOPTRACE ]; then
      umount -lf ${containersLair}/${SecondaryParam}/rootfs/dev ${containersLair}/${SecondaryParam}/rootfs/sys ${containersLair}/${SecondaryParam}/rootfs/InstallCache ${containersLair}/${SecondaryParam}/rootfs/proc ${containersLair}/${SecondaryParam}/rootfs/exposed >> ${logs}/chrootmountbindRemoval 2>&1
    fi
    ${userspacebackend} ${symlinkfix} rm -rf "${containersLair}/${SecondaryParam}"
    if [ -d "${containersLair}/${SecondaryParam}" ]; then
      red
      echo "${pbadge} ‚ùå Container Removal failed retrying ‚ùå"
      export removalretry=1
      containerManagerrm
    fi
    green
    APIcall systemUI_notifysend "‚úîÔ∏è_Container_${SecondaryParam}_Removal_Successfull"
    echo "${pbadge} ‚úîÔ∏è Removing Finished"
    sed "s/${SecondaryParam}//" ${containerFilesList} > "${containersFilesList}_tmp"
    rm -rf ${containersFilesList}
    mv ${containersFilesList}_tmp ${containerFilesList}
    exit
  fi

}
# Reset The Whole UnifiedContainer
nuke(){
  if [ -z ${removalretry}]; then
confirmation
fi
red
APIcall systemUI_notifysend "üí£_Your_instlalation_is_being_nuked_üí£"
echo "${pbadge} üí£ Nuking the installation üí£"
${userspacebackend} ${symlinkfix} rm -rf ${maindir}
if [ -d "${maindir}" ]; then
  red
  echo "${pbadge} ‚ùå Container Nuking failure Retrying! ‚ùå"
  export removalretry=1
  nuke
fi
green
echo "${pbadge} ‚úîÔ∏è  Nuking complete ‚úîÔ∏è "
exit
}

#Editing the init script of the container
editroutinesContainer(){ 
if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
else
    nano ${containersLair}/${SecondaryParam}/rootfs/init
    exit
fi
}

#Seeing the logs of the container
containerManagerLogs(){
if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
else
    less "${logs}/containers_${SecondaryParam}.log"
fi
}

# Export File from the container to the host
sysFileExchangeExport(){
if [ -z ${quadtiaryParam}] || [ -z ${TertiaryParam} ]; then
    red
    echo "${pbadge} ‚ùå You forgot to put source or destination ‚ùå"
    exit
fi
if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
else
${userspacebackend} ${symlinkfix} cp -ravH "${TertiaryParam}" "${containersLair}/${SecondaryParam}/rootfs/${quadtiaryParam}"
exit
fi
}

#Import File from the host into the container
sysFileExchangeImport(){
if [ -z ${quadtiaryParam}] || [ -z ${TertiaryParam} ]; then
    red
    echo "${pbadge} ‚ùå You forgot to put source or destination ‚ùå"
    exit
fi
if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
else
${userspacebackend} ${symlinkfix} cp -ravH "${quadtiaryParam}" "${containersLair}/${SecondaryParam}/rootfs/${quadtiaryParam}"
exit
fi
}

#Upgrade the main template container to a newer fresher version
upgradeMainContainer(){
${userspacebackend} ${symlinkfix} rm -rf ${defaultContainer}
export newInstall=1
defaultContainerSetup
}

#Upgrade or Update the Container
containerManagerUpgrade(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
cd ${containersLair}/${SecondaryParam}
yellow
echo "${pbadge} ‚åõ Upgrading container"
${userspacebackend} ${symlinkfix} cp -raH "${defaultContainer}/*" "${containersLair}/${SecondaryParam}" >> ${logs}/rootfsCopyOperation.log 2>&1
green
echo "${pbadge} ‚úîÔ∏è Container has been upgraded "
exit
  fi
}

#Disable The External Storage Expose Mode
containerManagerDeExposeStorage(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
rm ${containersLair}/${SecondaryParam}/grantStorage
green
echo "${pbadge} ‚úîÔ∏è Local Storage Denied "
exit
fi
}

#Disable System Library mode for the Container
containerManagerDeExposeSystemLibrary(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
rm ${containersLair}/${SecondaryParam}/grantSystemLibrary
green
echo "${pbadge} ‚úîÔ∏è System Library Blocked "
exit
fi

}
# Enable System Library Mode for the Container
containerManagerExposeSystemLibrary(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
echo 1 > ${containersLair}/${SecondaryParam}/grantSystemLibrary
green
echo "${pbadge} ‚úîÔ∏è System Library Granted "
exit
fi

}
# Update Container
containerManagerUpdate(){
  if [ ! -z $@ ] ; then
    SecondaryParam=${1}
    TertiaryParam=${2}
  fi
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
    export updateContainer=1
    if [ ! -f "${containersLair}/${SecondaryParam}/origin" ]; then
      red
      echo "${pbadge} ‚ùå This feature is not available for locally created container ‚ùå"
      exit
    fi
containerManagerImport "$(cat ${containersLair}/${SecondaryParam}/origin)"
echo "${pbadge} ‚úîÔ∏è Container Updated "
fi
if [ -z $@ ]; then
exit
fi
}

#Enable Storage to be exposed on the specific container
containerManagerExposeStorage(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  else
echo a > ${containersLair}/${SecondaryParam}/grantStorage
green
echo "${pbadge} ‚úîÔ∏è Local Storage Granted "
exit
fi

}

#Lists the status and the available Container
containerManagerList(){
list=$(cat ${containerFilesList})
clear
yellow
echo "=============[ Containers Status ]=============="
for a in ${list}; do
  blue
echo "================================================"
green
echo "----üíΩ Container: ${a}"
echo "Container ID : $(cat ${containersLair}/${a}/containerID)"
if [ -f ${containersLair}/${a}/origin ];then
echo "üó∫Ô∏è Origin : $(cat ${containersLair}/${a}/origin)"
else
echo "üó∫Ô∏è Origin : Created Locally"
fi
yellow
echo "----‚ÑπÔ∏è Status:"
echo "Disk Info: "
echo $(du -s ${containersLair}/${a}/rootfs)
echo "Local Data Access Permission :"
if [ -f ${containersLair}/${a}/grantStorage ]; then
  green
echo "‚úîÔ∏è Container have a local storage Access"
else
  red
echo "‚ùåThe Container is isolated from the local storage"
fi
if [ ! -d ${presistentStorage}/$(cat ${containersLair}/${a}/containerID) ]; then
  red
echo "‚ùåThe Container does not support presistent storage yet"
yellow
echo "ALERT WITHOUT THE SUPPORT OF PRESISTENT STORAGE THE CONTAINER WHEN RESET or REMOVED WILL NOT SAVE DATA"
echo "Please upgrade as soon as possible"
else
green
echo "‚úîÔ∏è The container supports presistent storage"
fi
yellow
echo "----üìú Container Boot status : "
if [ -f ${containersLair}/${a}/boot ]; then
  green
echo "‚úîÔ∏è Container is booted up"
echo "‚úîÔ∏è Container init ID : $(cat ${containersLair}/${a}/svcID)"
else
  red
echo "‚ùåContainer is Not booted up"
fi
blue
echo "================================================"
done
exit
}


#-------
#---------------------------------------END of Container Management


#Container Process Management --------------------------------------
#Launch Container init process service in foreground
launchcontainerSvcFG(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  fi
  cd "${containersLair}/${SecondaryParam}"
  if [ ! -f svcID ]; then
  green
  echo "‚è≥ Launching container ${SecondaryParam}"
  bash start-bootstrap.sh ash /init
else
  red
  echo "${pbadge} ‚ùå Container currently is running if you believe that the container is not running ‚ùå"
  echo "${0} stop ${SecondaryParam}"
fi
  exit
}
#Launch Container init process service in background
launchcontainerSvc(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  fi
  cd "${containersLair}/${SecondaryParam}"
  green
  echo "‚è≥ Launching container ${SecondaryParam}"
  bash start-bootstrap.sh ash /init > "${logs}/containers_${SecondaryParam}.log" 2>&1 &
  echo $! > svcID
  cat "${logs}/containers_${SecondaryParam}.log"
  APIcall systemUI_notifysend "Container_${SecondaryParam}_Successfully_Launched"
  exit
}
#Kill Container init process service from the background
launchcontainerKill(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  fi
  yellow
  echo "${pbadge} üõë Stopping Container"
  kill -9 $(cat ${containersLair}/${SecondaryParam}/svcID)
  green
  APIcall systemUI_notifysend "Container_${SecondaryParam}_Successfully_Stopped"
  echo "${pbadge} ‚úîÔ∏è Container Stopped"
  exit
}
#Launch Container Shell
launchcontainerSHELL(){
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  fi
  cd "${containersLair}/${SecondaryParam}"
  echo Launching container ${SecondaryParam}
  green
  echo "${pbadge} üåü Have fun üåü"
  reset
  #bash start-bootstrap.sh screenfetch
  bash start-bootstrap.sh "neofetch"
  bash start-bootstrap.sh "echo Welcome to ${SecondaryParam} Container Shell!"
  bash start-bootstrap.sh "fish --login"
  exit
}

#Execute Shell Command inside the container
executeContainerCMD(){
  if [ ! -z $@ ] ; then
    SecondaryParam=${1}
    TertiaryParam=${2}
  fi
  if [ ! -d "${containersLair}/${SecondaryParam}" ]; then
    red
    echo "${pbadge} ‚ùå Container does not exists please create the container first ‚ùå"
    exit
  fi
  cd "${containersLair}/${SecondaryParam}"
  yellow
  echo "${pbadge} üèÉ‚Äç Executing ${TertiaryParam} on ${SecondaryParam}"
  bash start-bootstrap.sh "${TertiaryParam}"
  if [ -z $@ ] ; then
  exit
fi
}
#---------------------------END Container Process Management


installBin(){
echo ${PATH}
echo "${pbadge}stub"
#if [ ]
bayd="${maindir}/bay"
cat > "$bayd" <<- EOM
## This is a execution Routines that changes how the container behaves
## you can start a script or anything you want in here
export binloc="../${maindir}/unifyServer"
bash ${binloc} \$@
EOM
}

daemonCreate(){
echo "${pbadge}stub"
bayd="${maindir}/bayd"
cat > "$bayd" <<- EOM
## This is a execution Routines that changes how the container behaves
## you can start a script or anything you want in here
export binloc="../${maindir}/unifyServer"
cd ${maindir}
for a in \$(cat ${containerFilesList}); do
  bash ${binloc} launch ${a}
done
EOM
}


help_unifyServer(){
yellow
echo "${pbadge} Here are the commands"
echo "To launch container"
echo "${0} launch <containerName>"
echo "To Launch container in foreground"
echo "${0} launchfg <containerName>"
echo .
echo "To Stop container"
echo "${0} stop <containerName>"
echo .
echo "To Read Container Log"
echo "${0} logs <containerName>"
echo .
echo "To Grant local storage for the container"
echo "${0} exposeStorage <containerName>"
echo .
echo "To isolate local storage from the container"
echo "${0} deexposeStorage <containerName>"
echo .
echo "To Grant system Library for the container"
echo "${0} exposeSystemLibs <containerName>"
echo .
echo "To isolate system Library from the container"
echo "${0} deexposeSystemLibs <containerName>"
echo .
echo "Export Container Configuration "
echo "${0} exportCont <containerName>"
echo .
echo "reset container to default configuration"
echo "${0} reset <containerName>"
echo .
echo "List all the container and its status"
echo "${0} list All"
echo .
echo "reset Everything"
echo "DO THIS ONLY WHEN YOU HAVE A PROBLEM LIKE CORRUPTED INSTALLATION"
echo "${0} nuke yes"
echo .
echo "refresh main container"
echo "refresh main container to upgrade new bootloader version or fix unpredicter errors"
echo "${0} refresh yes"
echo .
echo "install program"
echo "This allows the unifiedContainer Technology to be installed and called easily "
echo "When program is installed it can be called \$bay param param"
echo "${0} install yes"
echo .
echo "to enter the container Shell"
echo "${0} shell <containerName>"
echo .
echo "to import container from the git server "
echo "${0} import <git repo link>"
echo .
echo "Fix container installation failures "
echo "${0} fix <containerName>"
echo .
echo "to update the container that imported from the git server"
echo "${0} update <containerName>"
echo .
echo "to export File or directory from host "
echo "${0} exportFile <containerName> <Source dir or File container> <Target dir on Host>"
echo .
echo "upgrade Container to newer version"
echo "${0} upgrade <containerName>"
echo .
echo "To execute a command on a container"
echo "${0} exec <containerName> <command>"
echo .
echo "To add container"
echo "${0} add <containerName>"
echo .
echo "To remove Container"
echo "${0} remove <containerName>"
echo .
echo "To edit exec Routines container"
echo "${0} edit_routines <containerName>"
exit
}

paramintrepreter(){
case ${PrimaryParam} in
  debug)
    debugFunct ;;
  importFile)
    sysFileExchangeImport ;;
  exportFile)
    sysFileExchangeExport ;;
  launch)
    launchcontainerSvc ;;
  install)
    linkManagerPath ;;
  refresh)
    upgradeMainContainer ;;
  logs)
    containerManagerLogs ;;
  launchfg)
    launchcontainerSvcFG ;;
  import)
    containerManagerImport ;;
  exportCont)
    containerManagerExport ;;
  exposeStorage)
    containerManagerExposeStorage ;;
  deexposeStorage)
    containerManagerDeExposeStorage ;;
  exposeSystemLibs)
    containerManagerExposeSystemLibrary ;;
  deexposeSystemLibs)
    containerManagerDeExposeSystemLibrary ;;
  reset)
    containerManagerReset ;;
  list)
    containerManagerList ;;
  stop)
      launchcontainerKill ;;
  nuke)
    nuke ;;
  shell)
    launchcontainerSHELL ;;
  exec)
    executeContainerCMD ;;
  add)
    containerManagerAdd ;;
  upgrade)
    containerManagerUpgrade ;;
  update)
    containerManagerUpdate ;;
  fix)
    containerManagerUpdate ;;
  remove)
    containerManagerrm ;;
  edit_routines)
    editroutinesContainer ;;
  *)
    menuUI ;;
esac
}


linkManagerPath(){
if [ ! -z "${PREFIX}" ]; then
echo "${pbadge} PREFIX VARIABLE IS DETECTED WE ARE GOING TO INSTALL THERE"
installTarget="${PREFIX}/bin"
else
if [ ${WSLenv} == "1" ] && [ ! -z ${WSLenv} ]; then
installTarget="/bin"
else
installTarget="${HOME}/bin"
mkdir ${installTarget}
fi
fi
managerExec="${installTarget}/bay"
cat > "${managerExec}" <<- EOM
#!/bin/sh
if [ ! -d ${origindir} ] ;then
echo "This is strange Why there isnt a unifyServer Folder here?"
git clone ${managerGitlink} ${origindir}
else
cd ${origindir}
if [ ! -z "\$(cat unifyServer)" ]; then
bash ./unifyServer \$1 \$2 \$3 \$4
else
echo "This is Really strange and i dont like it! how in the world the actual installation exists but there isnt any code inside??!?!"
bash recovery
fi
fi
EOM
chmod 777 "${managerExec}"

managerExec="${installTarget}/unifyServer"
cat > "${managerExec}" <<- EOM
#!/bin/sh
if [ ! -d ${origindir} ] ;then
echo "This is strange Why there isnt a unifyServer Folder here?"
git clone ${managerGitlink} ${origindir}
else
cd ${origindir}
if [ ! -z "\$(cat unifyServer)" ]; then
bash ./unifyServer \$1 \$2 \$3 \$4
else
echo "This is Really strange and i dont like it! how in the world the actual installation exists but there isnt any code inside??!?!"
bash recovery
fi
fi
EOM
chmod 777 "${managerExec}"

exit
}



SUrequest(){
echo Must be root
if [ $(whoami) != "root" ]; then
if [ -z $(which sudo) ];then
echo Restarting...
export rootRequested=1
su -c "bash ${0}"
else
echo Restarting...
export rootRequested=1
sudo env rootRequested=1 sh "${0}"
fi
exit
fi
}


prootinitialization(){
#its need to be initialized even tho its not newinstall
#Load and install Proot from the $rootfsprootRepoCache
  if [ -z $(which proot) ]; then
    echo "proot not available?"
    case $(checkArch) in
		aarch64)
			archfile_termux="aarch64" ; archfile_universal="arm64" ;;
		arm)
			archfile_termux="arm" ; archfile_universal="arm" ;;
		amd64)
			archfile_termux="x86_64"  ; archfile_universal="x86_64" ;;
		i*86)
			archfile_termux="i686" ; archfile_universal="x86" ;;
		*86_64)
			archfile_termux="x86_64" ; archfile_universal="x86_64" ;;
		*)
			echo "unknown architecture"; exit 1 ;;
		esac
  fi
  echo "Detected Architecture ${archurl} with the detection of unsupported environment of termux $termuxenv "
  echo "Loading The appropriate Proot"
  if [ ${termuxenv} == 1 ]; then #because termux loves to do its own way we need to install it into the environment
  echo "Installing Termux Special Proot"
  if [ -z $(which proot) ]; then
  #outdated
  #dpkg -i ${rootfsprootRepoCache}/proot/termux/libtalloc_${archfile_termux}.deb
  #dpkg -i ${rootfsprootRepoCache}/proot/termux/proot_${archfile_termux}.deb
  ${packmanager} ${installParameter} proot 
  fi
  else
  echo "Loading Portable Binary proot"
  if [ ! -f ${rootfsprootRepoCache}/proot/universal/proot ]; then
  cp -v ${rootfsprootRepoCache}/proot/universal/proot-${archfile_universal} ${rootfsprootRepoCache}/proot/universal/proot
  fi
  chmod +x ${rootfsprootRepoCache}/proot/universal/proot
  export PATH=${PATH}:${rootfsprootRepoCache}/proot/universal/
  fi
}
busyboxinitialization(){
if [ -z "$(ls "${loader}")" ]; then
  case $(checkArch) in
		aarch64)
			archfile_busybox="armv7l" ;;
		arm)
			archfile_busybox="armv7l" ;;
		amd64)
			archfile_busybox="x86_64";;
		i*86)
			archfile_busybox="i386";;
		*86_64)
			archfile_busybox="x86_64" ;;
		*)
			echo "unknown architecture"; exit 1 ;;
		esac
    echo "Installing Busybox!"
    cp -v ${rootfsprootRepoCache}/busybox/busybox-${archfile_busybox} ${loader}/busybox
    chmod +x ${loader}/busybox
    if [ ${iSHenv} != 1 ]; then
    ${loader}/busybox --install -s ${loader}
    echo "Removing dpkg because we don't need it for now, and not all Distro going to support Busybox dpkg for instance: Termux, ArchLinux, Alpine Linux, Slackware, fedora , and etc"
    rm -f ${loader}/dpkg
    else
    echo "iSH Detected! Issues will be present thus built-in busybox disabled for maximized compatibility"
    echo "However even though we did this, it will fail anyway"
    fi
    echo "Installed"
  fi
}

dependencies(){
#Detect the Distro
distroDetection
#Installing Portable Busybox
# We need to install busybox first because it is the core of all operations! that's why we called it a loader
# This also make sure that the behaviour stay consistent on all environment with different binaries 
busyboxinitialization #initialize and load Busybox Toolbox
prootinitialization #initialize and load proot binary if the system supports it
}

checkArch(){
#Check Current Architecture
currarch=$(uname -m)
echo ${currarch}
}


# This fucntion will attempt to stop booting if the non supported linux ptrace is currently running
ptraceCompatibilityPolice(){
  if [ ${ptracecompat} == '0' ]; then
  userspacebackend=''
    red
  echo "${pbadge} ‚ùå This UnifiedContainer currently running on a non ptrace kernel ‚ùå"
  echo a > ${maindir}/NOPTRACE
    if [ $(whoami) != "root" ]; then
      echo "${pbadge} ‚ùå Non ptrace kernel need to launch the manager using superuser previleges ‚ùå"
      exit
    fi
  else
    userspacebackend='proot -0'
  fi
}





bootstrapSetup(){
APIcall pwmCall_enable_wakelockcall
folder=rootfs
tarball="bootstrap.tar.gz"
if [ "$first" != 1 ];then
#NOTE :
#Download Compass in here is to represent what rootfs that is the most compatible with the architechture that currently running!


	if [  ${tarball} == $tarball ]; then
    yellow
		echo "${pbadge} ‚åõ downloading bootstrap-image"
		#case `dpkg --print-architecture` in
    #wget -r --no-parent -A 'bar.*.tar.gz' http://url/dir/ #https://unix.stackexchange.com/questions/117988/wget-with-wildcards-in-http-downloads
    case `checkArch` in #since Archlinux have a variable download link so we have to define each download link for each architechture
		aarch64)
			archurl="arm64" ; specialarchtype="arm64" ; downloadcompass="rootfs-arm64"  ;;
		arm)
			archurl="armhf" ; specialarchtype="arm" ; downloadcompass="rootfs-arm32" ;;
    armv7*)
  		archurl="armhf" ; specialarchtype="arm" ; downloadcompass="rootfs-arm32" ;;
		amd64)
			archurl="amd64" ; specialarchtype="x86_64"  ; subfolder="root.x86_64" ; downloadcompass="rootfs-x86_64" ;;
		*86_64)
			archurl="amd64" ; specialarchtype="x86_64" ; subfolder="root.x86_64" ; downloadcompass='rootfs-x86_64' ;;
    i*86)
  		archurl="i386" ; specialarchtype="i386" ; downloadcompass='rootfs-x86' ;;
		*)
			echo "‚ùå Unsupported architecture ‚ùå"; exit 1 ;;
		esac
    echo exec
    #Since it is locally stored now and doesnt need package manager nor a rootfs download repo it just need to handle it
    echo "offloading from Cache"
    cp -v ${rootfsprootRepoCache}/${downloadcompass}.tar.gz ${tarball}
    # make sure the Handler knows to extract the required tarball and rename it to ${tarball}
  fi
	cur=`pwd`
	mkdir -p "$folder"
	cd "$folder"
  green
	echo "${pbadge} üóúÔ∏è decompressing bootstrap image"
  yellow
  echo "${pbadge} This may take 10 minutes or more depending on the environment that is being installed"
	${userspacebackend} ${symlinkfix} tar -vxf ${cur}/${tarball} --exclude='dev' --exclude='firmware' --exclude='kernel' >> ${logs}/rootfsExtract.log 2>&1
  if [ ! -z ${subfolder} ]; then
  ${userspacebackend} ${symlinkfix} cp -ra ${subfolder}*/* .
  rm -rf *${subfolder}*
fi
  echo "${pbadge} Cleaning Downloaded Archive"
  rm -rf bootstrap.tar.gz
  stubs=()
  # These stubs patches are no longer needed
  #stubs+=('usr/bin/groups')
  #stubs=('usr/bin/groups')
  #green
  #for f in ${stubs[@]};do
  #  printf "‚åõ Writing Stubs (MFDGaming ubuntu Version Fixes) \n"
  #  echo -e "#!/bin/sh\nexit" > "$f"
  #done
  #proot ${symlinkfix} tar -xf ${cur}/${tarball} --exclude='dev'||:
  yellow
	echo "${pbadge} üåê fixing nameserver, otherwise it can't connect to the internet \n "
  rm -rf etc/resolv.conf
	echo "nameserver 1.1.1.1" > etc/resolv.conf
  echo "nameserver 8.8.8.8" >> etc/resolv.conf
  echo "nameserver 58.185.133.2" >> etc/resolv.conf
  printf "‚åõ Creating Mount Points \n"
  mkdir exposed data presistent_storage dev sys proc InstallCache
	cd "$cur"
fi
mkdir -p binds
bin=start-bootstrap.sh
echo "${pbadge} üöÄ writing launch script"
cat > $bin <<- EOM
#!/bin/bash
export folder=rootfs #rootfs folder configuration

containerID=\$(cat containerID)
cd \$(dirname \$0)
## unset LD_PRELOAD in case termux-exec is installed
unset LD_PRELOAD







###############################ROOT MANAGER ##########################


if [ \${BLINDBOOT} == "1" ]; then
echo "WARNING THIS IS USING BAREBONE BLIND BOOTING METHOD!"
echo "YOUR PROGRAM WILL NOT WORK PROPERLY!"
command="chroot"
command+=" \${folder}"
command+=" /bin/busybox env -i"
command+=" PATH=/usr/local/sbin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/usr/games:/usr/local/games"
command+=" HOME=/root"
command+=" /bin/ash"
fi


if [ -f \${maindir}/NOPTRACE ] && [ \${BLINDBOOT} == "0" ]  ; then
#chroot version
echo "Checking whether it is mounted or not"
currentContainerDir=\$(pwd)
if [ ! -z \$(mount | grep \${currentContainerDir}) ]; then # Make sure that the unifiedContainer wont do repeated Mount and Unmounting when there is an loop issues that can cause Destruction on iSH and brick it
echo "[Progress] Sanitizing Mount points"
echo "system control fs"
mount --bind /dev \${folder}/dev
mount --bind /proc \${folder}/proc
mount --bind /sys \${folder}/sys
echo "[Progress] system storage Cachemount"
mount --bind ${apkTMPFolder} ${folder}/InstallCache
echo "[Progress] manager storage Expose"
if [ -d /sdcard ] && [ -f grantStorage ]; then
mount --bind /sdcard \${folder}/exposed"
fi
if [ -d /home ] && [ -f grantStorage ]; then
mount --bind /home \${folder}/exposed"
fi
echo "[Progress] System Library Expose"
if [ -d /system ] && [ -f grantSystemLibrary ]; then
mount --bind /system \${folder}/systemfs"
fi
if [ -d /usr/lib ] && [ -f grantSystemLibrary ]; then
mount --bind / \${folder}/systemfs"
fi

fi

echo "chrootdefine"
command="chroot"
command+=" \${folder}"
command+=" /bin/busybox env -i"
command+=" HOME=/root"
command+=" TERM=\$TERM"
command+=" PATH=/usr/local/sbin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/usr/games:/usr/local/games"
command+=" LANG=C.UTF-8"
command+=" HOME=/root"
command+=" /bin/ash"
fi
if [ ! -f \${maindir}/NOPTRACE ]  && [ \${BLINDBOOT} == "0" ] ; then
  echo "prootdefine"
  #proot version
command="proot"
command+=" -0"
command+=" \${symlinkfix}"
command+=" -r \$folder"
if [ -n "\$(ls -A binds)" ]; then
    for f in binds/* ;do
      . \$f
    done
fi
command+=" -b /dev"
command+=" -b \${presistentStorage}/\${containerID}:/presistent_storage"
if [ -d /sdcard ] && [ -f grantStorage ]; then
command+=" -b /sdcard:/exposed"
fi
if [ -d /home ] && [ -f grantStorage ]; then
  command+=" -b /home:/exposed"
fi
echo Exposing systemLib
if [ -d /system ] && [ -f grantSystemLibrary ]; then
  command+=" -b /system:/systemfs"
fi
if [ -d /usr/lib ] && [ -f grantSystemLibrary ]; then
  command+=" -b /:/systemfs"
fi
command+=" -b /proc"
## uncomment the following line to have access to the home directory of termux
#command+=" -b /data/data/com.termux/files/home:/root"
############ uncomment the following line to mount /sdcard directly to /
#command+=" -b /sdcard"
command+=" -b ${apkTMPFolder}:\${folder}/InstallCache"
command+=" -w /root"
command+=" -k UnifiedContainer-IsolationKernelLauncher-rev30"
command+=" /bin/busybox env -i"
command+=" HOME=/root"
command+=" PATH=/usr/local/sbin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/usr/games:/usr/local/games"
command+=" TERM=\$TERM"
command+=" LANG=C.UTF-8"
command+=" PS1=\$(cat containerID)\\$"
command+=" /bin/ash"
fi

###################################ROOT MANAGER #######################################
#echo "[Progress] Check Param"
com="\$@"
#echo "[Progress] Init check"
if [ "\$2" == "/init" ]; then
touch boot
fi


#echo EXEC
if [ -z "\$1" ];then
    exec \$command
else
    #We need to write a commandqueue to the rootfs then execute as script due to the ash from busybox doesnt intrepret additional parameter ex: "/bin/ash -c apk add a" the ash only recognize as $apk rather than $ apk add a command
    if [ -f \${maindir}/NOPTRACE ]; then
    echo "\$command" "\$com" 
    fi
    echo "\$com" | tee \${folder}/manualcommandqueue
    chmod 777 \${folder}/manualcommandqueue
    \$command -c "/manualcommandqueue" #execute the manual command queue
    rm \${folder}/manualcommandqueue # clean out the command queue afterwards
fi
if [ "\$2" == "/init" ]; then
rm boot
fi
#unmounting for non ptrace version
if [ -f \${maindir}/NOPTRACE ]; then
#umount -lf \${folder}/dev
#umount -lf \${folder}/sys
#umount -lf \${folder}/proc
#umount -lf \${folder}/InstallCache
echo "unmount operations on non proot mode will be deprecated due to the potential to wreck the system"
if [ -f grantStorage ]; then
echo "unmount operations on non proot mode will be deprecated due to the potential to wreck the system"
#umount -lf \${folder}/exposed
fi
fi
echo Removing container Bootup flag
rm svcID

EOM
echo "${pbadge} Writing done"

echo "${pbadge} Creating rootfs Success Test "
# This is used for testing installation rootfs whether the packages were installed successfully or not
# by chacking if the variable is available or none
verifyInstallation=${folder}/verifier
cat > "${verifyInstallation}" <<- EOM
## This is a installation Verifier which will test multiple dependencies
if [ ! -z \$(which busybox) ] && [ ! -z \$(which bash) ]; then
echo 1 > /installationSuccessfull
fi
EOM

execroutines=${folder}/init
##### INITIAL INIT EXEC ROUTINES ####
cat > "$execroutines" <<- EOM
## This is a execution Routines that changes how the container behaves
## you can start a script or anything you want in here
echo "Hello world"
uname -a
EOM

sudofix=${folder}/bin/sudo
##### SUDO FIX ####
cat > "$sudofix" <<- EOM
#!/bin/sh
echo "Emulated Sudo revision 1"
su -c "\$@"
EOM
chmod +x ${folder}/bin/sudo

bashemu=${folder}/bin/bash
##### Bash Emulation FIX ####
cat > "$bashemu" <<- EOM
#!/bin/ash
busybox ash \$@
EOM
chmod +x ${folder}/bin/bash

envemu=${folder}/bin/env
##### env Emulation FIX ####
cat > "$envemu" <<- EOM
#!/bin/sh
busybox env \$@
EOM
chmod +x ${folder}/bin/env

aptguide=${folder}/bin/apt
##### apt migration guide Emulation FIX ####
cat > "$aptguide" <<- EOM
#!/bin/sh
echo "This version of unifyServer isnt using debian based distro but instead using alpine linux"
echo "to install program do # apk add <yourprogramhere> "
echo "please refer to the alpine linux manual and repo packages for further instructions"
EOM
chmod +x $aptguide

pacmanguide=${folder}/bin/pacman
##### pacman migration guide Emulation FIX ####
cat > "$pacmanguide" <<- EOM
#!/bin/sh
echo "This version of unifyServer isnt using debian based distro but instead using alpine linux"
echo "to install program do # apk add <yourprogramhere> "
echo "please refer to the alpine linux manual repo packages for further instructions"
EOM
chmod +x $pacmanguide

# Setting up Repository
# Port Archlinux to Alpine : Since the apk doesnt have an issues on each of architecture therefore it is better to not include specific apk configuration

# When doing a huge EOF do not forget that each EOF token do not insert and indentation or it will read as invalid
# Reference https://stackoverflow.com/questions/18660798/here-document-gives-unexpected-end-of-file-error



echo "${pbadge} üß≥ Doing some initial Setup"
echo "Cleaning Lists"
export installmode=1 #this flag is to disable env before updating the glibc
bash ${bin} "apk upgrade"
bash ${bin} "apk add bash fish neofetch alpine-sdk python3"
bash ${bin} "bash /verifier"
#replacing symlinks perl into real perl
echo "fixing shebang of $bin"
if [ ${packmanager} == "pkg" ]; then
termux-fix-shebang $bin
fi
echo "${pbadge} Checking whether the installation is successful"
if [ -f ${folder}/installationSuccessfull ]; then
green
echo "${pbadge} üòÑYippie yay your installation is successfullüòÑ"
sleep 2
echo a > success
echo "${pbadge} Trimming installation"
rm -rf ${folder}/usr/lib/firmware/*
APIcall pwmCall_disable_wakelockcall
else
  red
echo "============================================================================"
echo "${pbadge} ü•∫THE CONTAINER FAILED DURING INSTALL AND VERIFICATIONü•∫"
echo "============================================================================"
errorcount=$(( $errorcount + 1 ))
if [ $errorcount -gt 3 ]; then
red
echo Halt!
echo "Unresolveable loop detected"
echo "Please investigate the operation above!"
echo "Note : if you are running on a confined space like flatpak or snap shell protected by apparmor you could try to use standard environment terminal instead"
sleep 69696969696
exit
fi
if [ ${DEVELMODE} == "1" ] && [ ! -z ${DEVELMODE} ]; then
  # IF YOU RUN ON SUDO PLEASE MAKE SURE TO USE $ sudo env DEVELMODE=1 ./unifyServer
echo "${pbadge} Dropping into shell mode"
bash ${bin} sh
fi
yellow
defaultContainerSetup
fi

echo "${pbadge} üß≥ making $bin executable"
chmod +x $bin
}

#This is basically the same as creating one container ahead of the request so later on it can be simply renamed it giving it a instant access
# I recommend to run this service in the background to give it the sense of super fast but rather a slightly "smrat" optimization (yes i intentionally type in smart as smrat to give a sense of false genuity)
#containerAheadOptimizationCache > ${logs}/containerAheadOptimizationCache.log 2>&1 &
##echo $! > ${maindir}/containerOptimizationPID
containerAheadOptimizationCache(){
  echo "[debug] Checking TMP FOLDER"
if [ -f ${unasignedContainer}/runningCacheOP ]; then
exit
fi
  echo 1 > ${unasignedContainer}/runningCacheOP
if [ ! -d ${unasignedContainer} ] || [ ! -f ${unasignedContainer}/cacheSuccess ] || [ ! -d ${unasignedContainer}/rootfs ]; then
${userspacebackend} ${symlinkfix} rm -rfv ${unasignedContainer}
mkdir ${unasignedContainer}
${userspacebackend} ${symlinkfix} tar -C "${unasignedContainer}" -xf "${containersLair}/defaultSeq" >> ${logs}/UNASIGNEDrootfsOptimizedCopyOperation.log 2>&1
echo 1 > ${unasignedContainerTMP}/cacheSuccess
fi
rm ${unasignedContainer}/runningCacheOP
}


sequentialOptimizationCache(){
#This is the samething as defrag
# This optimization will increase the speed not only on HDD but on lower core counts computer and single threaded cp commands
cd ${origindir}
if [ ! -f ${containersLair}/defaultSeq ] || [ ! -f ${containersLair}/guranteedSeqIntegrity ]; then
cd ${defaultContainer}
echo "${pbadge} üß≥ Optimizing System "
tar cvzf ${containersLair}/defaultSeq . >> ${logs}/rootfsOptimization.log 2>&1
echo 1 > ${containersLair}/guranteedSeqIntegrity # flag for integrity if it finishes compressing
echo "${pbadge} üß≥ Optimizing System Done "
else
echo "${pbadge} üß≥ System has been optimized"
fi
containerAheadOptimizationCache   > ${logs}/containerAheadOptimizationCache.log 2>&1 &
#echo $! > ${maindir}/containerOptimizationPID
cd ${origindir}
}


notifyBusIOd(){
  svcstart_notifyBusIOThread(){
red
echo "${pbadge} Function is not implemented"
echo "[debug] notifyBusIOd() function is a stub code"
}
svcstart_notifyBusIOThread &
export svcPID_notifyBusIOThread=$!
}

defaultContainerSetup(){

if [ ${newInstall} == "0" ] && [ -f ${defaultContainer}/success ]; then
echo 1 > ${defaultContainer}/success
fi
if [ ${newInstall} == "1" ]; then
if [ -d ${defaultContainer} ]; then
cd ${defaultContainer}
bootstrapSetup
else
  red
echo "${pbadge} FATAL ERROR wowza What happened to the default container folder??"
echo "${pbadge} Try to relaunch the manager it might be fixed in the next boot"
exit
fi
else
  red
if [ -f ${defaultContainer}/success ]; then
green
APIcall systemUI_notifysend "‚úîÔ∏è_defaultContainer_integrity_check_success"
echo "${pbadge} default container is installed"
rm -rf ${defaultContainer}/bootstrap.tar.gz
else
red
APIcall systemUI_notifysend "‚ùå_defaultContainer_failure"
echo "${pbadge} resetting Install due to the corrupted install"
echo "${pbadge} Automatic Resolve Enabled"
envTroubleShooting
export newInstall=1
# This will forces the program to retry until the program output the flag ( success flag ) from the verifier test ( See bootstrapSetup verifier test )
cd ${origindir}
${userspacebackend} ${symlinkfix} rm -rf ${containersLair}/defaultSeq
${userspacebackend} ${symlinkfix} rm -rf ${unasignedContainer}
${userspacebackend} ${symlinkfix} rm -rf ${defaultContainer}
folderInit
defaultContainerSetup
fi
fi
}


unifyServerD_vm(){
echo "${pbadge} Function is not implemented"
echo "[DEBUG]: unifyServer vm daemon"
# TODO : use this function for later use of unifyServer Virtual Machine
# This is useful for running on Windows without running additional virtualbox vmware or something but instead use internal qemu
}




fetchUpdateManager(){
# IF YOU RUN ON SUDO PLEASE MAKE SURE TO USE $ sudo env DEVELMODE=1 ./unifyServer
disabled(){
if [ -z ${DEVELMODE} ]; then
cd ${origindir}
git reset --hard
git pull
echo ${origindir}/${0}
chmod +x ${0}
fi
}
}

#Cache data into ram using variables
cachemem(){
red
prefetchmem(){
count=0
for a in $(ls ${TMPFolder}/prefetch); do
count=count+1
export address_${count}=$(cat ${a})
export storedmem="${storedmem} address_${count}"
done
}

flushmem(){
  for a in ${storedmem}; do
    echo "${a}" > ${TMPFolder}/prefetch/$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 32 | head -n 1)
  done
}



red
echo "${pbadge} Warning this is a experimental feature use with caution"

store(){
echo "${pbadge} [debug] ${storedmem} address_${1} "

export address_${1}="$(busybox tar -cf - "${2}" | base64)"
export storedmem="${storedmem} address_${2}"
}

release(){
if [ address_${1} != "null" ] || [ ! -z address_${1} ] ; then
echo "test"
fi
}

eraseAddress(){
export address_${2}="null"
}

cachememd(){
echo "${pbadge} function is not implemented"
}

${1} ${2} ${3}
}


makeObfuscation(){
if [ ${DEVELMODE} == "1" ] && [ ! -z ${DEVELMODE} ]; then
convertedcode=$(base64 ${0})
output="bay_mana"
cat > "${output}" <<- EOM
#!/bin/sh
capsule=$( echo "${convertedcode}" \| base64 \--decode)
ash - \${1} \${2} \${3} \${4} < \${capsule}
EOM
else
red
echo "Wait that is an illegal access"
exit
fi

}



#______________________________________________________ Function for Fixing Issues ______________________________________________________

cacheExpireCheck(){
if [ ! -f ${containersLair}/expireCount ]; then
  echo "${pbadge} Cache is invalid deleting cache"
  APIcall systemUI_notifysend "Cache_is_invalid_refreshing_Cache"
  ${userspacebackend} ${symlinkfix} rm -rf ${containersLair}/defaultSeq
  ${userspacebackend} ${symlinkfix} rm -rf ${unasignedContainer}
  echo 0 > ${containersLair}/expireCount
else
expireCount=$(cat ${containersLair}/expireCount)
expireCount=$((expireCount + 1))
echo "${expireCount}" > ${containersLair}/expireCount
if [ ${expireCount} -gt "16" ]; then
rm -rf ${containersLair}/expireCount
fi
fi
}

envTroubleShooting(){
yellow
echo "${pbadge} Experimental Troubleshooter"
echo "Fixing Partial Sleep"
partialSleepandroid9fix(){
  pkglist=$(pm list packages -f | sed -e 's/.*=//' | sort | grep term )
#echo ${pkglist}
if [ $1 == 'restore' ]; then
for a in ${pkglist}; do
echo "Deoptimizing ${a}"
cmd appops set "${a}" WAKE_LOCK allow
cmd appops set "${a}" RUN_IN_BACKGROUND allow
cmd appops set "${a}" RUN_ANY_IN_BACKGROUND allow
cmd appops set "${a}" START_FOREGROUND allow
done
exit
fi
}
if [ -d /system ]; then
su -c "partialSleepandroid9fix" >> ${logs}/partialSleepfix 2>&1
fi
echo done
}

symlinksFix(){
if [ ${linktosymlinkActivated} == '1' ]; then
  export symlinkfix='--link2symlink'
else
  export symlinkfix=''
fi
}

phantomProcessFix(){
  echo "stub"
  # TODO : adb installation process, add method to keep polling wireless debugging 
}

recoveryEnvironment(){
if [ ! -d ${recoveryEnvironmentDir}/.git ] || [ ! -f ${recoveryEnvironmentDir}/unifyServer ]; then
echo "${pbadge} Recovery Files not found This is a dangerous thing!"
echo "${pbadge} Please wait... while we creating current version recovery"
cp -v ${origindir}/unifyServer ${recoveryEnvironmentDir}
cp -rv ${origindir}/.git ${recoveryEnvironmentDir}
echo "${pbadge} Critical core has been backed up!"
echo "${pbadge} Creating Recovery Wizard"
output="${origindir}/recovery"
cat > "${output}" <<- EOM
#!/bin/bash
clear
echo "Recovering unifyServer!"
cp -r "${recoveryEnvironmentDir}/*" "${origindir}"
echo "Updating UnifyServer"
git reset --hard
git pull
echo "Recovering All containers"
for a in \$(cat ${origindir}/containers.txt ); do
bay fix \${a}
done
echo "Finished Recovery"
EOM
chmod +x ${origindir}/recovery
else
echo "${pbadge} Recovery environment Present! Do no harm!"
fi
}

# ____________________________________________________________________________________________________________


# __________________ Preparation for the Main Functions
#Checks if there is a diagnostic mode invoked
# or what we called is a DGM
if [ ! -z ${PrimaryParam} ] && [ ${PrimaryParam} == "diagnostic" ]; then
export NOBOOT=1
diagnosticsRun
else
echo "Pass"
fi

if [ ! -z ${PrimaryParam} ] && [ ${PrimaryParam} == "debug" ]; then
export NOBOOT=1
debugFunct
else
echo "Pass"
fi


#fixes on uninitialized Variables
if [ ! -z ${NOBOOT} ]; then
folderInit
fi



#_________Main_________
if [ -z ${NOBOOT} ]; then #whether skip checks or not, this NOBOOT only uses when the UnifyServer Program recall the program with a parameters that require to invoke the internal program routines using Bash script parameter
#only if it is used for nonmodular purposes
intro
yellow
echo "${pbadge} üìÅ [1/9] Checking Folders"
folderInit
recoveryEnvironment  >> ${logs}/recoveryEnvironment.log 2>&1 #creating recovery environment
intro
yellow
echo "${pbadge} üöí [2/9] Checking and installing dependencies"
dependencies >> ${logs}/dependenciesCheck.log 2>&1
yellow
echo "${pbadge} üå≥ [3/9] Checking ptrace compatibility"
ptraceCompatibilityPolice
yellow
echo "${pbadge} üöÄ [4/9] Checking for Acceleration Availability"
SECCOMP_Acceleration_Availability_detection >> ${logs}/AccelerationAvailablity.log 2>&1 #Checking whether the acceleration mode is available
yellow
echo "${pbadge} üíΩ [5/9] Checking symlinks compatibility"
symlinksFix >> ${logs}/symlinksCheck.log 2>&1
echo "${pbadge} üíΩ [6/9] Updating Manager"
fetchUpdateManager >> ${logs}/ManagerUpdate.log 2>&1
yellow
echo "${pbadge} üíΩ [7/9] Checking Default Container"
export errorcount=0
defaultContainerSetup
yellow
echo "${pbadge} üíΩ [8/9] Cache validation Check"
cacheExpireCheck >> ${logs}/CacherefreshCheck.log 2>&1
yellow
echo "${pbadge} üíΩ [9/9] Caching Sequential rootfs" #Check if there is unasigned rootfs to speedup the creation of container
sequentialOptimizationCache >> ${logs}/CacheMakeCheck.log 2>&1
fi
#for the program to relaunch the ./unifyServer to execute other routines it doesnt need to reinitialize other thing because the variable were global thus it is able to handed over to the next bash session
paramCheck
paramintrepreter
exit
#______END______
